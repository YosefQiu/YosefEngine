### main thread

```c++
//in my engine only main thread memory
while(1) --> main thread
{
    1. update();
    2. render();
}
```



### 内存池的好处

考虑一个问题：如果系统内存128GB， 内存池200MB，如果需要一个地址空间来放数据。从哪里获取更方便。

在程序启动后，内存池会从系统那这里获取一个固定大小的内存块，以后所有应用程序的内存都从这个内存块里分配。此外，还可以屏蔽系统差异带了的应用程序的表现差异。



### [TLSF(Two-Level Segregated Fit)](https://github.com/mattconte/tlsf)

对于实时的系统，对worst case 有要求

1. 最坏情况应该可估计  O(1) cost for malloc, free, re-malloc, memory-malign
2. 稳定 -》采用相同的策略去分配内存
3. 内存碎片小

Next is my reading note of a [paper](http://www.gii.upv.es/tlsf/files/ecrts04_tlsf.pdf)

**Abstract**

The use of DSA has been considered a source of indeterminism in the real-time domain, due to the unconstrained response time of DSA algorithms and the fragmentation problem.

New real-time applications require more flexibility: the ability to adjust system configuration in response to workload changes and application reconfiguration.

**Introduction**

In real-time systems, it is needed to know in advance the operation time bounds in order to analyze the system schedulability.

TLSF, for dynamic memory allocation that presents a bounded worst-case response time, while keeping the efficiency of the allocation and deallocation operations with a temporal cost of O(1). A small and bounded fragmentation is also achieved by the TLSF.

**Real-Time Requirements for DSA**

Most non-real-time applications take only a few minutes or hours to complete their work and finalize. Real-time applications are usually executed continuously during the whole life of the system, which leads to memory fragmentation problems.

- Bounded response time
- Fast response time
- Memory requests need to be always satisfied

**Fragmentation**

Memory exhaustion may occur due to two reasons:

- The application requires more memory that the total memory available in the system
- The DSA is unable to reuse memory that is free,
  - internal frag
  - external frag

**DSA Algorithms**

- Sequential Fit
- Segregated Free Lists
- Buddy Systems
- Indexed Fit
- Bitmap Fit

**DSA Operational Model**

A DSA is an abstract data type that keeps track of which blocks of memory are in use and which are free. 

- Insert a free block
- Search for  a free block of a given size or larger
- Search for a block adjacent to another
- Remove a free block

**TLSF Data Structures**

The basic segregated fit mechanism uses an array of free lists, with each array holding free blocks within a size class.

- The first-level array divides free blocks into classes that are a power of two apart (16, 32, 64, 128, etc.)
- The second-level sub-divides each first-level class linearly

The TLSF embeds into each block the information needed to manage the block (whether the block is free or not) and the pointers to link it into the two lists: the list of blocks of similar sizes and the list ordered by physical addresses.

Most TLSF operations rely on the segregate list() mapping function. Given the size of a block, the mapping function calculates the indexes of the two arrays that point to the corresponding segregated list that holds the requested block.
$$
mapping(size)→(f,s)
$$

$$
mapping(size) = \left\{
\begin{aligned}
f:= \lfloor log_2(size)\rfloor \\
s:= (size-2^f)\frac{2^{SLI}}{2^f}
\end{aligned}
\right.
$$

- Initialize TLSF structure
- Destroy TLSF structure
- Get a free block
- First step
- Second step
- Insert a free block
- Coalesce blocks



#### 内存对齐

```c++
size_t alloc_memory_size = (size + (align - 1)) & ~(align - 1);
```

